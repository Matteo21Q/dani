rg <- function(dat, mle) {
# Function to generate random exponential variates.
# mle will contain the mean of the original data
out <- data.frame(matrix(NA,1,2))
out[1,1] <- rbinom(1,mle[2], mle[1])
out[1,2] <- rbinom(1,mle[4], mle[3])
out
}
res.b<-boot(dd, rdif, R = M.boot, sim = "parametric",
ran.gen = rg, mle = c(p0.tilde,n.control,p1.tilde,n.experim))
CI<-boot.ci(res.b, type=bootCI.type, conf=1-sig.level*2)[[4]][4:5-2*(bootCI.type=="norm")]
estimate<-res.b$t0
}
estimate.n<-mean(CI)
if (is.null(se)) {
se<-(CI[2]-CI[1])/(2*qnorm(1-sig.level))
is.se.est<-T
} else {
is.se.est<-F
}
if (isTRUE(recursive.p.estim)) {
if (estimate==NI.margin) {
p=0.5
} else {
sig.lev.est<-try(uniroot(func.to.opt, c(10^(-15), 0.5-10^(-15)),
n.control=n.control, n.experim=n.experim,
e.control=e.control, e.experim=e.experim,
NI.margin=NI.margin, summary.measure=summary.measure,
unfavourable=unfavourable, test.type=test.type,
M.boot=M.boot, BB.adj=BB.adj,
tol = 0.000001)$root, silent=TRUE)
if (!inherits(sig.lev.est,"try-error")) {
p<-ifelse(((unfavourable==T)&&(estimate>NI.margin))||
((unfavourable==F)&&(estimate<NI.margin)),
1-sig.lev.est, sig.lev.est)
} else {
p<-NULL
warning("recursive estimation of p failed. Providing standard estimate.\n")
}
}
}
if (is.null(p)) {
Z <- ifelse(unfavourable==T,(estimate.n - NIm)/se,(-estimate.n + NIm)/se)
p <- pnorm(Z)
is.p.est<-T
} else {
is.p.est<-F
}
if ((unfavourable==T&&CI[2]<NI.margin)||(unfavourable==F&&CI[1]>NI.margin)) {
non.inferiority<-T
} else {
non.inferiority<-F
}
if (print.out==T) {
cat("Testing for non-inferiority.\nSummary measure: Risk difference.\nNon-inferiority margin = ", NI.margin, ".\nMethod: ",test.type,
".\nEstimate = ", estimate,
"\nConfidence interval (Two-sided ", (1-sig.level*2)*100,"%): (", CI[1], ",", CI[2],
")\np-value = ", p, ".\n" , sep="")
if ((unfavourable==T&&CI[2]<NI.margin)||(unfavourable==F&&CI[1]>NI.margin)) {
cat("The confidence interval does not cross the null ( RD = ", NI.margin, " ), and hence we have evidence of non-inferiority.\n", sep="")
} else {
cat("The confidence interval crosses the null ( RD = ", NI.margin, " ), and hence we have NO evidence of non-inferiority.\n", sep="")
}
if (is.p.est==T) {
if (is.se.est==T) {
cat("Note: with the test = ",test.type, " for summary measure = ", summary.measure,", p-value and standard error are only approximations based on a Z test with given logarithm of estimate and CI.\n")
} else {
cat("Note: with the test = ",test.type, " for summary measure = ", summary.measure,", p-value is only an approximation based on a Z test with given logarithm of estimate and CI.\n")
}
}
}
} else if (summary.measure == "RR") {
t2x2<-matrix(c(e.experim, n.experim-e.experim, e.control, n.control-e.control), nrow = 2, byrow = TRUE)
if ((unfavourable == T)&&(NI.margin<=1)) stop("When outcome is unfavourable, a NI margin on the risk ratio scale needs to be >1.")
if ((unfavourable == F)&&(NI.margin>=1)) stop("When outcome is favourable, a NI margin on the risk ratio scale needs to be <1.")
if (NI.margin<=0) stop("A risk ratio margin must be >0.\n")
NIm<- log(NI.margin)
if (test.type=="Wald.Katz") {
if ((e.control==0)||(e.experim==0)) stop("Wald.Katz interval not computable in presence of zero cell counts (e.control=0 or e.experim=0).\n")
se <- sqrt(1/e.control-1/n.control+1/e.experim-1/n.experim)
estimate <- log((e.experim/n.experim)/(e.control/n.control))
Z <- ifelse( unfavourable==T, (estimate - NIm)/se, -(estimate - NIm)/se)
p <- pnorm(Z)
CI <- exp(c(estimate-qnorm(1-sig.level)*se,estimate+qnorm(1-sig.level)*se))
estimate <- exp(estimate)
} else if (test.type=="adjusted.Wald.Katz") {
se <- sqrt(1/(e.control+0.5)-1/(n.control+0.5)+1/(e.experim+0.5)-1/(n.experim+0.5))
estimate <- log(((e.experim+0.5)/(n.experim+0.5))/((e.control+0.5)/(n.control+0.5)))
Z <- ifelse( unfavourable==T, (estimate - NIm)/se, -(estimate - NIm)/se)
p <- pnorm(Z)
CI <- exp(c(estimate-qnorm(1-sig.level)*se,estimate+qnorm(1-sig.level)*se))
estimate <- exp(estimate)
} else if (test.type=="inverse.hyperbolic.sine") {
if (e.experim==0) t2x2[1,1]<-round(qnorm(1-sig.level)^2)
if (e.control==0) t2x2[2,1]<-round(qnorm(1-sig.level)^2)
test<-Inv_sinh_CI_ratio_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="Koopman") {
test<-Koopman_asymptotic_score_CI_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="Miettinen.Nurminen") {
test<-MiettinenNurminen_asymptotic_score_CI_ratio_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="MOVER.R") {
test<-MOVER_R_Wilson_CI_ratio_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="MOVER") {
test<-moverci(e.experim,n.experim,e.control,n.control,contrast = "RR", level = 1-2*sig.level)
CI<-test[c(1,3)]
estimate<-test[2]
} else if (test.type=="Gart.Nam") {
test<-scasci(e.experim,n.experim,e.control,n.control,contrast = "RR", level = 1-2*sig.level)$estimates
CI<-test[c(1,3)]
estimate<-test[2]
} else if (test.type=="score.cc") {
test<-ratesci::scoreci(e.experim,n.experim,e.control,n.control,contrast = "RR", level = 1-2*sig.level, cc=T)$estimates
CI<-test[c(1,3)]
estimate<-test[2]
} else if (test.type=="Bailey") {
test<-BinomRatioCI(x1 = e.experim, n1 = n.experim, x2 = e.control, n2 = n.control, method = "bailey")
CI<-test[2:3]
estimate<-test[1]
} else if (test.type=="Noether") {
test<-BinomRatioCI(x1 = e.experim, n1 = n.experim, x2 = e.control, n2 = n.control, method = "noether")
CI<-test[2:3]
estimate<-test[1]
} else if (test.type=="bootstrap") {
rrat <- function(dat, indices) {
d <- dat[indices,] # allows boot to select sample
rr <- log(mean(d[d$treatment!=control.level,"outcomes"])) - log(mean(d[d$treatment==control.level,"outcomes"]))
return(rr)
}
res.b<-boot(mydata, rrat, R=M.boot)
CI<-exp(boot.ci(res.b, type=bootCI.type, conf=1-sig.level*2)[[4]][4:5-2*(bootCI.type=="norm")])
estimate<-exp(res.b$t0)
} else if (test.type == "Agresti.Min") {
fit<-uncondExact2x2(e.control,n.control,e.experim,n.experim, method="score", tsmethod = "square", conf.int = T, parmtype="ratio")
CI <- as.numeric(fit$conf.int)
estimate<-as.numeric(fit$estimate)
} else if (test.type == "Chan.Zhang") {
fit<-uncondExact2x2(e.control,n.control,e.experim,n.experim, method="score", tsmethod = "central", conf.int = T, parmtype="ratio")
CI <- as.numeric(fit$conf.int)
estimate<-as.numeric(fit$estimate)
} else if (test.type == "uncond.midp") {
fit<-uncondExact2x2(e.control,n.control,e.experim,n.experim, method="score", tsmethod = "square", midp=T, conf.int = T, parmtype="ratio")
CI <- as.numeric(fit$conf.int)
estimate<-as.numeric(fit$estimate)
} else if (test.type == "Berger.Boos") {
fit<-uncondExact2x2(e.control,n.control,e.experim,n.experim, method="score", tsmethod = "square", gamma=BB.adj, conf.int = T, parmtype="ratio")
CI <- as.numeric(fit$conf.int)
estimate<-as.numeric(fit$estimate)
} else if (test.type=="logistic") {
fit<-glm(myformula, data=mydata, family = binomial)
fit.std<-avg_comparisons(fit, conf_level = (1-sig.level*2), comparison="lnratio", transform = exp)
CI <- c(fit.std[fit.std$term=="treatment","conf.low"], fit.std[fit.std$term=="treatment","conf.high"])
estimate<-fit.std[fit.std$term=="treatment","estimate"]
} else if (test.type=="logregression") {
if (e.experim==0||e.control==0) stop("logregression not possible with zero cell counts (e.control=0 or e.experim=0).\n")
fit<-glm(myformula, data=mydata, family = binomial(link="log"))
row.treat<-which(grepl("treatment", row.names(coef(summary(fit)))))
estimate<-exp(coef(summary(fit)))[row.treat,"Estimate"]
CI <- exp(suppressMessages(confint(fit, level = 1-sig.level*2))[row.treat,])
}
estimate.n<-mean(log(CI))
if (is.null(se)) {
se<-(log(CI[2])-log(CI[1]))/(2*qnorm(1-sig.level))
is.se.est<-T
} else {
is.se.est<-F
}
if (isTRUE(recursive.p.estim)) {
if (estimate==NI.margin) {
p=0.5
} else {
sig.lev.est<-try(uniroot(func.to.opt, c(10^(-15), 0.5-10^(-15)),
n.control=n.control, n.experim=n.experim,
e.control=e.control, e.experim=e.experim,
NI.margin=NI.margin, summary.measure=summary.measure,
unfavourable=unfavourable, test.type=test.type,
M.boot=M.boot, BB.adj=BB.adj,
tol = 0.000001)$root, silent=TRUE)
if (!inherits(sig.lev.est,"try-error")) {
p<-ifelse(((unfavourable==T)&&(estimate>NI.margin))||
((unfavourable==F)&&(estimate<NI.margin)),
1-sig.lev.est, sig.lev.est)
} else {
p<-NULL
warning("Recursive estimation of p failed. Providing standard estimate.\n")
}
}
}
if (is.null(p)) {
Z <- ifelse(unfavourable==T,(estimate.n - NIm)/se,(-estimate.n + NIm)/se)
p <- pnorm(Z)
is.p.est<-T
} else {
is.p.est<-F
}
if ((unfavourable==T&&CI[2]<NI.margin)||(unfavourable==F&&CI[1]>NI.margin)) {
non.inferiority<-T
} else {
non.inferiority<-F
}
if (print.out==T) {
cat("Testing for non-inferiority.\nSummary measure: Risk ratio.\nNon-inferiority margin = ", NI.margin, ".\nMethod: ",test.type,
".\nEstimate = ", estimate,
"\nConfidence interval (Two-sided ", (1-sig.level*2)*100,"%): (", CI[1], ",", CI[2],
")\np-value = ", p, ".\n" , sep="")
if ((unfavourable==T&&CI[2]<NI.margin)||(unfavourable==F&&CI[1]>NI.margin)) {
cat("The confidence interval does not cross the null ( RR = ", NI.margin, " ), and hence we have evidence of non-inferiority.\n", sep="")
} else {
cat("The confidence interval crosses the null ( RR = ", NI.margin, " ), and hence we have NO evidence of non-inferiority.\n", sep="")
}
if (is.p.est==T) {
if (is.se.est==T) {
cat("Note: with the test = ",test.type, " for summary measure = ", summary.measure,", p-value and standard error are only approximations based on a Z test with given logarithm of estimate and CI.\n")
} else {
cat("Note: with the test = ",test.type, " for summary measure = ", summary.measure,", p-value is only an approximation based on a Z test with given logarithm of estimate and CI.\n")
}
}
}
} else if (summary.measure == "AS") {
is.p.est<-is.se.est<-F
NIm<-NI.margin
if ((unfavourable == T)&&(NI.margin<=0)) stop("When outcome is unfavourable, a NI margin on the arc-sine difference scale needs to be >0.")
if ((unfavourable == F)&&(NI.margin>=0)) stop("When outcome is favourable, a NI margin on the arc-sine difference scale needs to be <0.")
if (test.type=="Wald") {
se <- sqrt(1/(4*n.control)+1/(4*n.experim))
estimate <- asin(sqrt(e.experim/n.experim))-asin(sqrt(e.control/n.control))
Z <- (estimate - NIm)/se
p <- pnorm(Z)
CI <- c(estimate-qnorm(1-sig.level)*se,estimate+qnorm(1-sig.level)*se)
} else if (test.type=="logistic") {
fit<-glm(myformula, data=mydata, family = binomial)
fit.std<-avg_comparisons(fit, conf_level = (1-sig.level*2), comparison=function(hi, lo) asin(sqrt(hi))-asin(sqrt(lo)))
CI <- c(fit.std[fit.std$term=="treatment","conf.low"], fit.std[fit.std$term=="treatment","conf.high"])
estimate<-fit.std[fit.std$term=="treatment","estimate"]
se<-fit.std[fit.std$term=="treatment","std.error"]
p<-NULL
} else if (test.type=="bootstrap") {
asdif <- function(dat, indices) {
d <- dat[indices,] # allows boot to select sample
as<-asin(sqrt(mean(d[d$treatment!=control.level,"outcomes"])))-asin(sqrt(mean(d[d$treatment==control.level,"outcomes"])))
return(as)
}
res.b<-boot(mydata, asdif, R=M.boot)
CI<-boot.ci(res.b, type=bootCI.type, conf=1-sig.level*2)[[4]][4:5-2*(bootCI.type=="norm")]
estimate<-res.b$t0
}
estimate.n<-mean(CI)
if (is.null(p)) {
Z <- ifelse(unfavourable==T,(estimate.n - NIm)/se,(-estimate.n + NIm)/se)
p <- pnorm(Z)
is.p.est<-T
} else {
is.p.est<-F
}
if (isTRUE(recursive.p.estim)) {
if (estimate==NI.margin) {
p=0.5
} else {
sig.lev.est<-try(uniroot(func.to.opt, c(10^(-15), 0.5-10^(-15)),
n.control=n.control, n.experim=n.experim,
e.control=e.control, e.experim=e.experim,
NI.margin=NI.margin, summary.measure=summary.measure,
unfavourable=unfavourable, test.type=test.type,
M.boot=M.boot, BB.adj=BB.adj,
tol = 0.000001)$root, silent=TRUE)
if (!inherits(sig.lev.est, "try-error")) {
p<-ifelse(((unfavourable==T)&&(estimate>NI.margin))||
((unfavourable==F)&&(estimate<NI.margin)),
1-sig.lev.est, sig.lev.est)
} else {
warning("Recursive estimation of p failed. Providing standard estimate.\n")
}
}
}
if ((unfavourable==T&&CI[2]<NI.margin)||(unfavourable==F&&CI[1]>NI.margin)) {
non.inferiority<-T
} else {
non.inferiority<-F
}
if (print.out==T) {
cat("Testing for non-inferiority.\nSummary measure: Arc-sine difference.\nNon-inferiority margin = ", NI.margin, ".\nMethod: ",test.type,
".\nEstimate = ", estimate,
"\nConfidence interval (Two-sided ", (1-sig.level*2)*100,"%): (", CI[1], ",", CI[2],
")\np-value = ", p, ".\n" , sep="")
if ((unfavourable==T&&CI[2]<NI.margin)||(unfavourable==F&&CI[1]>NI.margin)) {
cat("The confidence interval does not cross the null ( ASD = ", NI.margin, " ), and hence we have evidence of non-inferiority.\n", sep="")
} else {
cat("The confidence interval crosses the null ( ASD = ", NI.margin, " ), and hence we have NO evidence of non-inferiority.\n", sep="")
}
}
} else if (summary.measure == "OR") {
t2x2<-matrix(c(e.experim, n.experim-e.experim, e.control, n.control-e.control), nrow = 2, byrow = TRUE)
if ((unfavourable == T)&&(NI.margin<=1)) stop("When outcome is unfavourable, a NI margin on the odds ratio scale needs to be >1.")
if ((unfavourable == F)&&(NI.margin>=1)) stop("When outcome is favourable, a NI margin on the odds ratio scale needs to be <1.")
if (NI.margin<=0) stop("A odds ratio margin must be >0.\n")
NIm<- log(NI.margin)
if (test.type=="Wald.Woolf") {
if (e.experim==0||e.control==0) stop("Wald.Woolf not informative with zero cell counts (e.control=0 or e.experim=0).\n")
se <- sqrt(1/e.control+1/(n.control-e.control)+1/e.experim+1/(n.experim-e.experim))
estimate <- log((e.experim/(n.experim-e.experim))/(e.control/(n.control-e.control)))
Z <- ifelse( unfavourable==T, (estimate - NIm)/se, -(estimate - NIm)/se)
p <- pnorm(Z)
CI <- exp(c(estimate-qnorm(1-sig.level)*se,estimate+qnorm(1-sig.level)*se))
estimate <- exp(estimate)
} else if (test.type=="adjusted.Wald.Woolf") {
se <- sqrt(1/(e.control+0.5)+1/(n.control-e.control+0.5)+1/(e.experim+0.5)+1/(n.experim-e.experim+0.5))
estimate <- log(((e.experim+0.5)/(n.experim-e.experim+0.5))/((e.control+0.5)/(n.control-e.control+0.5)))
Z <- ifelse( unfavourable==T, (estimate - NIm)/se, -(estimate - NIm)/se)
p <- pnorm(Z)
CI <- exp(c(estimate-qnorm(1-sig.level)*se,estimate+qnorm(1-sig.level)*se))
estimate <- exp(estimate)
} else if (test.type=="IndSmooth.logit") {
test<-Independence_smoothed_logit_CI_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="Cornfield.exact") {
test<-Cornfield_exact_conditional_CI_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="Baptista.Pike.exact") {
test<-BaptistaPike_exact_conditional_CI_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="Cornfield.midp") {
test<-Cornfield_midP_CI_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="Baptista.Pike.midp") {
test<-BaptistaPike_midP_CI_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="inverse.hyperbolic.sine") {
test<-Inv_sinh_CI_OR_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="Miettinen.Nurminen") {
test<-MiettinenNurminen_asymptotic_score_CI_OR_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="MOVER.R") {
test<-MOVER_R_Wilson_CI_OR_2x2(t2x2, alpha = 2*sig.level)
CI<-as.numeric(test[1:2])
estimate<-as.numeric(test[3])
} else if (test.type=="MOVER") {
test<-moverci(e.experim,n.experim,e.control,n.control,contrast = "OR", level = 1-2*sig.level)
CI<-as.numeric(test[c(1,3)])
estimate<-as.numeric(test[2])
} else if (test.type=="Gart.Nam") {
test<-scasci(e.experim,n.experim,e.control,n.control,contrast = "OR", level = 1-2*sig.level)$estimates
CI<-as.numeric(test[c(1,3)])
estimate<-as.numeric(test[2])
} else if (test.type=="score.cc") {
test<-ratesci::scoreci(e.experim,n.experim,e.control,n.control,contrast = "OR", level = 1-2*sig.level, cc=T)$estimates
CI<-as.numeric(test[c(1,3)])
estimate<-as.numeric(test[2])
}  else if (test.type=="MLE") {
test<-OddsRatio(t2x2, method = "mle", conf.level = 1-sig.level*2)
CI<-as.numeric(test[c(2,3)])
estimate<-as.numeric(test[1])
} else if ( test.type == "bootstrap") {
if (e.control==0||e.experim==0) stop("bootstrap method not appropriate for zero cell counts (e.control=0 or e.experim=0).\n")
oddsr <- function(dat, indices) {
d <- dat[indices,] # allows boot to select sample
or <- log((sum(d[d$treatment!=control.level,"outcomes"], na.rm=T)/(sum(d$treatment!=control.level, na.rm=T)-sum(d[d$treatment!=control.level,"outcomes"], na.rm=T)))/(sum(d[d$treatment==control.level,"outcomes"], na.rm=T)/(sum(d$treatment==control.level, na.rm=T)-sum(d[d$treatment==control.level,"outcomes"], na.rm=T))))
return(or)
}
res.b<-boot(mydata, oddsr, R=M.boot)
CI<-exp(boot.ci(res.b, type=bootCI.type, conf=1-sig.level*2)[[4]][4:5-2*(bootCI.type=="norm")])
estimate<-exp(res.b$t0)
} else if (test.type == "Agresti.Min") {
fit<-uncondExact2x2(e.control,n.control,e.experim,n.experim, method="score", tsmethod = "square", conf.int = T, parmtype="oddsratio")
CI <- as.numeric(fit$conf.int)
estimate<-as.numeric(fit$estimate)
} else if (test.type == "Chan.Zhang") {
fit<-uncondExact2x2(e.control,n.control,e.experim,n.experim, method="score", tsmethod = "central", conf.int = T, parmtype="oddsratio")
CI <- as.numeric(fit$conf.int)
estimate<-as.numeric(fit$estimate)
} else if (test.type == "uncond.midp") {
fit<-uncondExact2x2(e.control,n.control,e.experim,n.experim, method="score", tsmethod = "square", midp=T, conf.int = T, parmtype="oddsratio")
CI <- as.numeric(fit$conf.int)
estimate<-as.numeric(fit$estimate)
} else if (test.type == "Berger.Boos") {
fit<-uncondExact2x2(e.control,n.control,e.experim,n.experim, method="score", tsmethod = "square", gamma=BB.adj, conf.int = T, parmtype="oddsratio")
CI <- as.numeric(fit$conf.int)
estimate<-as.numeric(fit$estimate)
} else if (test.type=="logistic") {
if (e.experim==0||e.control==0) stop("With zero cell counts (e.control=0 or e.experim=0) logistic method not informative.\n")
fit<-glm(myformula, data=mydata, family = binomial)
row.treat<-which(grepl("treatment", row.names(coef(summary(fit)))))
estimate<-exp(coef(summary(fit)))[row.treat,"Estimate"]
CI <- exp(suppressMessages(confint(fit, level = 1-sig.level*2))[row.treat,])
}
estimate.n<-mean(log(CI))
if (is.null(se)) {
se<-(log(CI[2])-log(CI[1]))/(2*qnorm(1-sig.level))
is.se.est<-T
} else {
is.se.est<-F
}
if (isTRUE(recursive.p.estim)) {
if (estimate==NI.margin) {
p=0.5
} else {
sig.lev.est<-try(uniroot(func.to.opt, c(10^(-15), 0.5-10^(-15)),
n.control=n.control, n.experim=n.experim,
e.control=e.control, e.experim=e.experim,
NI.margin=NI.margin, summary.measure=summary.measure,
unfavourable=unfavourable, test.type=test.type,
M.boot=M.boot, BB.adj=BB.adj,
tol = 0.000001)$root, silent=TRUE)
if (!inherits(sig.lev.est, "try-error")) {
p<-ifelse(((unfavourable==T)&&(estimate>NI.margin))||
((unfavourable==F)&&(estimate<NI.margin)),
1-sig.lev.est, sig.lev.est)
} else {
p<-NULL
warning("Recursive estimation of p failed. Providing standard estimate.\n")
}
}
}
if (is.null(p)) {
Z <- ifelse(unfavourable==T,(estimate.n - NIm)/se,(-estimate.n + NIm)/se)
p <- pnorm(Z)
is.p.est<-T
} else {
is.p.est<-F
}
if ((unfavourable==T&&CI[2]<NI.margin)||(unfavourable==F&&CI[1]>NI.margin)) {
non.inferiority<-T
} else {
non.inferiority<-F
}
if (print.out==T) {
cat("Testing for non-inferiority.\nSummary measure: Odds ratio.\nNon-inferiority margin = ", NI.margin, ".\nMethod: ",test.type,
".\nEstimate = ", estimate,
"\nConfidence interval (Two-sided ", (1-sig.level*2)*100,"%): (", CI[1], ",", CI[2],
")\np-value = ", p, ".\n" , sep="")
if ((unfavourable==T&&CI[2]<NI.margin)||(unfavourable==F&&CI[1]>NI.margin)) {
cat("The confidence interval does not cross the null ( OR = ", NI.margin, " ), and hence we have evidence of non-inferiority.\n", sep="")
} else {
cat("The confidence interval crosses the null ( OR = ", NI.margin, " ), and hence we have NO clear evidence of non-inferiority.\n", sep="")
}
if (is.p.est==T) {
if (is.se.est==T) {
cat("Note: with the test = ",test.type, " for summary measure = ", summary.measure,", p-value and standard error are only approximations based on a Z test with given logarithm of estimate and CI.\n")
} else {
cat("Note: with the test = ",test.type, " for summary measure = ", summary.measure,", p-value is only an approximation based on a Z test with given logarithm of estimate and CI.\n")
}
}
}
}
results <- list(estimate, se, p, CI, test.type, summary.measure, is.p.est, sig.level, non.inferiority)
names(results)<-c("estimate", "se", "p", "CI", "test.type", "summary.measure", "is.p.est", "sig.level", "non.inferiority")
return(results)
}
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=0.05, sig.level=0.025, summary.measure="RD",
print.out=TRUE, unfavourable=TRUE, test.type="binreg",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=0.05, sig.level=0.025, summary.measure="RD",
print.out=TRUE, unfavourable=TRUE, test.type="logistic",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=0.05, sig.level=0.025, summary.measure="RD",
print.out=TRUE, unfavourable=TRUE, test.type="bootstrap",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=1.5, sig.level=0.025, summary.measure="RR",
print.out=TRUE, unfavourable=TRUE, test.type="bootstrap",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=1.5, sig.level=0.025, summary.measure="RR",
print.out=TRUE, unfavourable=TRUE, test.type="logistic",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=1.5, sig.level=0.025, summary.measure="RR",
print.out=TRUE, unfavourable=TRUE, test.type="logregression",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=1.5, sig.level=0.025, summary.measure="OR",
print.out=TRUE, unfavourable=TRUE, test.type="logistic",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=1.5, sig.level=0.025, summary.measure="OR",
print.out=TRUE, unfavourable=TRUE, test.type="bootstrap",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=0.5, sig.level=0.025, summary.measure="AS",
print.out=TRUE, unfavourable=TRUE, test.type="bootstrap",
M.boot=2000, BB.adj=0.0001))
dataf2<-data.frame(y<-rep(c(1,0,1,0),c(15,85,15,85)), treat<-rep(c(1,0), each=100), age<-rep(c(20,30,40,50), 50), cacca=factor(rbinom(200,1,0.5)))
colnames(dataf2)<-c("y", "treat", "age", "cacca")
out5AT<-try(test.NI.binary(data=dataf2, formula=as.formula("y~treat(treat)+age+cacca"),  NI.margin=0.5, sig.level=0.025, summary.measure="AS",
print.out=TRUE, unfavourable=TRUE, test.type="logistic",
M.boot=2000, BB.adj=0.0001))
